<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Worker Test</title>
</head>
<body>
    <input type="file" id="imageInput" accept="image/*">
    <canvas id="inputCanvas"></canvas>
    <canvas id="outputCanvas"></canvas>
    <script>
        const imageInput = document.getElementById('imageInput');
        const inputCanvas = document.getElementById('inputCanvas');
        const outputCanvas = document.getElementById('outputCanvas');
        const ctx = inputCanvas.getContext('2d');
        const worker = new Worker('js/arrayWorkers.js');

        imageInput.addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (!file) return;

            const img = new Image();
            img.onload = function () {
                inputCanvas.width = img.width;
                inputCanvas.height = img.height;
                ctx.drawImage(img, 0, 0);

                const imageData = ctx.getImageData(0, 0, img.width, img.height);
                console.time("convertFile");
                worker.postMessage({
                    imageData: imageData.data,
                    width: img.width,
                    height: img.height,
                    minValue: -16,
                    maxValue: 108,
                    isInvertedColormap: false,
                    colorTable: [
                        { "value": -15, "color": [0, 0, 0, 0] },
                        { "value": 5, "color": [29, 37, 60, 255] },
                        { "value": 17.5, "color": [89, 155, 171, 255] },
                        { "value": 22.5, "color": [33, 186, 72, 255] },
                        { "value": 32.5, "color": [5, 101, 1, 255] },
                        { "value": 37.5, "color": [251, 252, 0, 199] },
                        { "value": 42.5, "color": [253, 149, 2, 172] },
                        { "value": 50, "color": [253, 38, 0, 135] },
                        { "value": 60, "color": [193, 148, 179, 200] },
                        { "value": 70, "color": [165, 2, 215, 64] },
                        { "value": 75, "color": [135, 255, 253, 54] },
                        { "value": 80, "color": [173, 99, 64, 255] },
                        { "value": 85, "color": [105, 0, 4, 255] },
                        { "value": 95, "color": [0, 0, 0, 255] }
                    ],
                    radar: true
                });
            };
            const reader = new FileReader();
            reader.onload = (e) => { img.src = e.target.result; };
            reader.readAsDataURL(file);
        });
        worker.onerror = (err) => {
            console.error("Worker encountered an error:", err);
            reject(err);
            worker.terminate();
        };
        worker.onmessage = function (e) {
            console.timeEnd("convertFile");
            const { rgbArray, imageDataArray } = e.data;
            console.log('rgbArray:', rgbArray);
            console.log('imageDataArray:', imageDataArray);

            rgbArrayTest = new Float32Array(rgbArray);
            imageDataArrayTest = new Uint8ClampedArray(imageDataArray);

            const outputCtx = outputCanvas.getContext('2d');

            const outputImageData = new ImageData(imageDataArrayTest, inputCanvas.width, inputCanvas.height);
            outputCanvas.width = inputCanvas.width * 4;
            outputCanvas.height = inputCanvas.height * 4;
            console.time("renderPPI");
            renderPPI(outputCtx, outputImageData, inputCanvas.width, inputCanvas.height, true)
            console.timeEnd("renderPPI");
        };

        function renderPPI(ctx, imageData, width, height, shouldLiveUpdate) {
            const data = imageData.data;
            const N = height;  // Number of azimuths (scan lines)
            const M = width;   // Number of range bins (radial resolution)
            const R = Math.min(ctx.canvas.width, ctx.canvas.height) / 2;
            const cx = R, cy = R; // Center of canvas

            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // Rotate entire canvas 90Â° counterclockwise
            ctx.save();
            ctx.translate(0, ctx.canvas.height);
            ctx.rotate(-Math.PI / 2);

            let i = 0; // Track the current azimuth
            const batchSize = Math.max(1, Math.floor(N / 120)); // Render ~60 frames

            function drawAzimuth(i) {
                let theta = (i / N) * 2 * Math.PI; // Angle for azimuth line

                for (let j = 0; j < M; j++) {
                    let srcIdx = (i * M + j) * 4;
                    if (data[srcIdx + 3] === 0) continue; // Skip fully transparent pixels

                    let r = (j / M) * R; // Radius for this range bin
                    let pixelSize = Math.max(1.5, (0.3 + 0.7 * Math.pow(j / M, 0.7)) * (R / M) * 4);// trial and error pixel length size

                    let x = cx + r * Math.cos(theta);
                    let y = cy + r * Math.sin(theta);
                    let alpha = data[srcIdx + 3] / 255; // Normalize alpha (0 to 1)

                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(theta); // Rotate according to azimuth
                    ctx.fillStyle = `rgba(${data[srcIdx]}, ${data[srcIdx + 1]}, ${data[srcIdx + 2]}, ${alpha})`;
                    ctx.fillRect(-pixelSize / 2, -pixelSize / 2, pixelSize, pixelSize * 1.5);
                    ctx.restore();
                }
            }

            function drawNextBatch() {
                let maxI = Math.min(i + batchSize, N);

                for (; i < maxI; i++) {
                    drawAzimuth(i);
                }

                if (shouldLiveUpdate && i < N) {
                    requestAnimationFrame(drawNextBatch);
                } else if (!shouldLiveUpdate && i >= N) {
                    ctx.restore(); // Restore transformation after full render
                }
            }

            if (shouldLiveUpdate) {
                drawNextBatch(); // Progressive rendering
            } else {
                for (i = 0; i < N; i++) {
                    drawAzimuth(i);
                }
                ctx.restore(); // Restore transformation after full render
            }
        }


    </script>
</body>
</html>
